# 安裝必要的套件
!pip install pytube

!pip install yt-dlp

import os
import re
import json
import subprocess
from google.colab import drive
import platform
import glob

# 掛載 Google Drive
drive.mount('/content/drive')

# 確保目標資料夾存在
output_dir = "/content/drive/My Drive/MUSIC"
os.makedirs(output_dir, exist_ok=True)

# 緩存目錄，用於存放cookies和其他臨時文件
cache_dir = "/content/yt_dlp_cache"
os.makedirs(cache_dir, exist_ok=True)

# 新增：為解決429錯誤的cookies設置
def setup_cookies():
    """設置cookies以避免429錯誤"""
    print("正在設置cookies以避免YouTube限制...")

    # 檢測操作系統和瀏覽器
    system = platform.system().lower()

    browsers = []
    if system == 'windows':
        browsers = ['chrome', 'edge', 'firefox', 'opera', 'brave', 'vivaldi', 'safari']
    elif system == 'darwin':  # MacOS
        browsers = ['chrome', 'firefox', 'safari', 'edge', 'opera', 'brave', 'vivaldi']
    else:  # Linux
        browsers = ['chrome', 'firefox', 'opera', 'brave', 'edge', 'vivaldi']

    # 使用Colab環境，我們無法直接獲取用戶的瀏覽器cookies
    # 但我們可以讓用戶選擇使用哪種方式處理429錯誤
    print("\n解決YouTube 429錯誤的方法:")
    print("1. 使用代理IP（減緩請求速率）")
    print("2. 手動設置User-Agent（模擬不同瀏覽器）")
    print("3. 手動輸入YouTube cookies（最有效但需要用戶操作）")

    choice = input("請選擇處理方式 (1/2/3): ")
    cookies_file = f"{cache_dir}/youtube_cookies.txt"
    user_agent = ""

    if choice == "1":
        # 使用代理選項（在yt-dlp中設置更慢的下載速率和更多重試）
        return "--socket-timeout 30 --sleep-interval 5 --max-sleep-interval 10 --retries 10"
    elif choice == "2":
        # 設置自定義User-Agent
        ua_options = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5 Safari/605.1.15",
            "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/117.0"
        ]
        print("\n請選擇User-Agent:")
        for i, ua in enumerate(ua_options, 1):
            print(f"{i}. {ua}")

        ua_choice = input("請選擇 (1/2/3): ")
        try:
            user_agent = ua_options[int(ua_choice) - 1]
            return f"--user-agent \"{user_agent}\""
        except:
            print("無效選擇，使用默認User-Agent")
            return ""
    elif choice == "3":
        # 指導用戶如何獲取並提供YouTube cookies
        print("\n== 如何提供YouTube cookies ==")
        print("1. 在瀏覽器中登入YouTube")
        print("2. 安裝Cookie Editor瀏覽器擴展")
        print("3. 前往YouTube網站，開啟Cookie Editor")
        print("4. 點擊「Export」按鈕，選擇「Export as Netscape HTTP Cookie File」")
        print("5. 將內容複製並貼上到下方")
        print("\n請貼上從Cookie Editor擴展匯出的cookies內容（貼上後按Enter再按Ctrl+D結束輸入）:")

        cookies_content = []
        while True:
            try:
                line = input()
                cookies_content.append(line)
            except EOFError:
                break

        # 將cookies寫入文件
        with open(cookies_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(cookies_content))

        if os.path.exists(cookies_file) and os.path.getsize(cookies_file) > 0:
            print("成功保存cookies!")
            return f"--cookies \"{cookies_file}\""
        else:
            print("cookies似乎為空，將嘗試不使用cookies")
            return ""
    else:
        print("無效選擇，不使用特殊參數")
        return ""

# 新增：測試YouTube連接
def test_youtube_connection(extra_params):
    """測試與YouTube的連接，檢查是否能夠正常訪問"""
    print("測試與YouTube的連接...")

    test_cmd = f'yt-dlp --dump-json "ytsearch1:test" {extra_params}'
    result = subprocess.run(test_cmd, shell=True, capture_output=True, text=True)

    if result.returncode == 0:
        print("✅ YouTube連接正常!")
        return True
    else:
        if "429" in result.stderr:
            print("❌ 仍然出現429錯誤，可能需要使用更有效的cookies或等待一段時間再試")
        elif "Unable to download webpage" in result.stderr:
            print("❌ 無法連接到YouTube，請檢查網絡連接")
        else:
            print(f"❌ 連接測試失敗: {result.stderr}")
        return False

def sanitize_filename(filename):
    """清理檔案名稱，移除不合法字元"""
    return re.sub(r'[\\/*?:"<>|]', "_", filename)

def search_song(song_name, prefer_full=True, extra_params=""):
    """使用 yt-dlp 搜尋歌曲並返回點閱率最高的影片URL

    參數:
    song_name: 搜尋的歌曲名稱
    prefer_full: 是否優先選擇較長的影片版本（很可能是完整版）
    extra_params: 額外的yt-dlp參數字符串
    """
    try:
        print(f"正在搜尋: {song_name}")

        # 使用更精確的搜尋關鍵詞來找到完整歌曲
        keywords = f"{song_name} full song"
        if "完整" not in song_name.lower() and "full" not in song_name.lower():
            keywords = f"{song_name} 完整版 full song"

        # 搜尋更多結果以增加找到完整版的機會
        search_query = f"ytsearch10:{keywords}"
        command = f'yt-dlp {extra_params} --dump-json "{search_query}"'

        # 執行命令並捕獲輸出
        result = subprocess.run(command, shell=True, capture_output=True, text=True)

        if result.returncode != 0:
            print(f"搜尋失敗: {result.stderr}")
            return None

        # 分析搜尋結果
        videos = []
        for line in result.stdout.strip().split('\n'):
            if line:
                try:
                    video_info = json.loads(line)
                    duration = video_info.get('duration', 0)  # 獲取影片時長（秒）

                    # 忽略過短的影片（小於60秒的通常是預告或片段）
                    if duration < 60:
                        continue

                    title = video_info.get('title', '未知標題')

                    # 檢查影片標題，排除預告、開場動畫等非完整版本
                    skip_keywords = ['trailer', 'teaser', 'preview', 'short', 'snippet', 'clip',
                                    '預告', '片段', '開場', 'OP', 'アニメ', 'PV', 'CM']

                    # 排除標題中包含明顯非完整版關鍵詞的影片
                    if any(keyword.lower() in title.lower() for keyword in skip_keywords):
                        if not any(fullword in title.lower() for fullword in ['full song', 'full version', '完整版']):
                            continue

                    videos.append({
                        'title': title,
                        'url': video_info.get('webpage_url', ''),
                        'channel': video_info.get('channel', '未知頻道'),
                        'view_count': video_info.get('view_count', 0),
                        'view_count_text': format_view_count(video_info.get('view_count', 0)),
                        'duration': duration,
                        'duration_text': format_duration(duration)
                    })
                except json.JSONDecodeError:
                    continue

        if not videos:
            print("找不到相關影片，嘗試使用更寬鬆的搜尋條件...")
            # 如果找不到結果，使用原始的搜尋方式
            return search_song_fallback(song_name, extra_params)

        # 首先按時長排序，然後按觀看次數排序
        if prefer_full:
            # 選擇時長大於2分鐘的影片中，觀看次數最高的
            long_videos = [v for v in videos if v['duration'] > 120]
            if long_videos:
                videos = long_videos

        # 依照觀看次數排序
        videos.sort(key=lambda x: x['view_count'], reverse=True)

        # 顯示搜尋結果
        print("\n找到以下影片:")
        for i, video in enumerate(videos[:5], 1):  # 只顯示前5個結果
            print(f"{i}. {video['title']} - {video['channel']} ({video['view_count_text']} 觀看次數, {video['duration_text']})")

        best_video = videos[0]
        print(f"\n已選擇點閱率最高的影片: {best_video['title']} ({best_video['view_count_text']} 觀看次數, {best_video['duration_text']})")

        return best_video['url']

    except Exception as e:
        print(f"搜尋時發生錯誤: {str(e)}")
        return None

def search_song_fallback(song_name, extra_params=""):
    """備用搜尋方法，使用較寬鬆的條件"""
    try:
        print(f"使用備用搜尋方法尋找: {song_name}")

        # 使用基本搜尋
        search_query = f"ytsearch10:{song_name}"
        command = f'yt-dlp {extra_params} --dump-json "{search_query}"'

        result = subprocess.run(command, shell=True, capture_output=True, text=True)

        if result.returncode != 0:
            print(f"備用搜尋失敗: {result.stderr}")
            return None

        videos = []
        for line in result.stdout.strip().split('\n'):
            if line:
                try:
                    video_info = json.loads(line)
                    duration = video_info.get('duration', 0)

                    # 完全忽略30秒以下的影片
                    if duration < 30:
                        continue

                    videos.append({
                        'title': video_info.get('title', '未知標題'),
                        'url': video_info.get('webpage_url', ''),
                        'channel': video_info.get('channel', '未知頻道'),
                        'view_count': video_info.get('view_count', 0),
                        'view_count_text': format_view_count(video_info.get('view_count', 0)),
                        'duration': duration,
                        'duration_text': format_duration(duration)
                    })
                except json.JSONDecodeError:
                    continue

        if not videos:
            print("找不到相關影片!")
            return None

        # 依照觀看次數排序
        videos.sort(key=lambda x: x['view_count'], reverse=True)

        print("\n備用搜尋找到以下影片:")
        for i, video in enumerate(videos[:5], 1):
            print(f"{i}. {video['title']} - {video['channel']} ({video['view_count_text']} 觀看次數, {video['duration_text']})")

        best_video = videos[0]
        print(f"\n已選擇點閱率最高的影片: {best_video['title']} ({best_video['view_count_text']} 觀看次數, {best_video['duration_text']})")

        return best_video['url']

    except Exception as e:
        print(f"備用搜尋時發生錯誤: {str(e)}")
        return None

def format_view_count(view_count):
    """將數字轉換為易讀的格式"""
    if view_count >= 1000000000:
        return f"{view_count/1000000000:.1f}B"
    elif view_count >= 1000000:
        return f"{view_count/1000000:.1f}M"
    elif view_count >= 1000:
        return f"{view_count/1000:.1f}K"
    else:
        return str(view_count)

def format_duration(seconds):
    """將秒數轉換為時分秒格式"""
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)

    if hours > 0:
        return f"{hours}:{minutes:02d}:{seconds:02d}"
    else:
        return f"{minutes}:{seconds:02d}"

def download_as_mp3(youtube_url, custom_filename=None, extra_params=""):
    """從 YouTube URL 下載 MP3"""
    try:
        print(f"正在處理: {youtube_url}")

        # 使用 yt-dlp 直接下載為 MP3
        output_template = f"{output_dir}/%(title)s.%(ext)s"
        if custom_filename:
            # 如果提供了自定義檔名，則使用它
            sanitized_name = sanitize_filename(custom_filename)
            output_template = f"{output_dir}/{sanitized_name}.%(ext)s"

        # 添加更多選項以確保音質和完整性
        command = f'yt-dlp {extra_params} --no-playlist -x --audio-format mp3 --audio-quality 0 --embed-thumbnail --add-metadata -o "{output_template}" "{youtube_url}"'

        print("執行下載命令...")
        result = subprocess.run(command, shell=True, capture_output=True, text=True)

        if result.returncode != 0:
            print(f"下載失敗: {result.stderr}")

            # 如果是429錯誤，提供更具體的提示
            if "429" in result.stderr:
                print("\n遇到429錯誤 (Too Many Requests)，這意味著YouTube認為我們的下載行為是自動程序。")
                print("請嘗試以下解決方案:")
                print("1. 等待一段時間後再試")
                print("2. 使用cookies選項重新運行此程序")
                print("3. 使用VPN或代理改變IP地址")
                return False
            return False

        print(f"下載完成!")
        return True
    except Exception as e:
        print(f"下載時發生錯誤: {str(e)}")
        return False

def select_from_search_results(song_name, extra_params=""):
    """讓使用者從搜尋結果中選擇影片"""
    try:
        print(f"正在搜尋: {song_name}")

        # 搜尋更多結果
        search_query = f"ytsearch10:{song_name}"
        command = f'yt-dlp {extra_params} --dump-json "{search_query}"'

        result = subprocess.run(command, shell=True, capture_output=True, text=True)

        if result.returncode != 0:
            print(f"搜尋失敗: {result.stderr}")
            return None

        videos = []
        for line in result.stdout.strip().split('\n'):
            if line:
                try:
                    video_info = json.loads(line)
                    duration = video_info.get('duration', 0)

                    videos.append({
                        'title': video_info.get('title', '未知標題'),
                        'url': video_info.get('webpage_url', ''),
                        'channel': video_info.get('channel', '未知頻道'),
                        'view_count': video_info.get('view_count', 0),
                        'view_count_text': format_view_count(video_info.get('view_count', 0)),
                        'duration': duration,
                        'duration_text': format_duration(duration)
                    })
                except json.JSONDecodeError:
                    continue

        if not videos:
            print("找不到相關影片!")
            return None

        # 依照觀看次數排序，但顯示時長
        videos.sort(key=lambda x: x['view_count'], reverse=True)

        # 顯示搜尋結果
        print("\n找到以下影片:")
        for i, video in enumerate(videos, 1):
            print(f"{i}. {video['title']} - {video['channel']} ({video['view_count_text']} 觀看次數, {video['duration_text']})")

        # 讓使用者選擇
        while True:
            try:
                choice = input("\n請選擇要下載的影片編號 (或輸入 0 取消): ")
                if choice == '0':
                    return None

                choice_idx = int(choice) - 1
                if 0 <= choice_idx < len(videos):
                    selected = videos[choice_idx]
                    print(f"\n已選擇: {selected['title']} ({selected['duration_text']})")
                    return selected['url']
                else:
                    print("無效的選擇，請輸入正確的編號")
            except ValueError:
                print("請輸入數字")

    except Exception as e:
        print(f"搜尋時發生錯誤: {str(e)}")
        return None

# 透過歌曲名稱下載 (改進版)
def download_song_by_name(extra_params=""):
    while True:
        song_name = input("請輸入歌曲名稱 (輸入 '0' 退出): ")
        if song_name.lower() == '0':
            break

        print("1. 自動選擇最佳結果 (優先選擇完整版)")
        print("2. 手動從搜尋結果中選擇")
        selection_mode = input("請選擇模式 (1/2): ")

        url = None
        if selection_mode == "2":
            # 手動選擇
            url = select_from_search_results(song_name, extra_params)
        else:
            # 自動選擇
            url = search_song(song_name, prefer_full=True, extra_params=extra_params)

        if url:
            # 詢問是否使用自定義檔名
            use_custom = input("是否使用自定義檔名? (y/n): ").lower() == 'y'

            custom_name = None
            if use_custom:
                custom_name = input("請輸入檔名 (不需要副檔名): ")

            # 下載歌曲
            download_as_mp3(url, custom_name, extra_params)
        else:
            print("無法找到合適的歌曲，請嘗試更具體的歌名或歌手名稱")

    print("程式已結束")

# 批次下載多首歌曲 (改進版)
def batch_download_songs(extra_params=""):
    song_names = []
    print("請輸入多個歌曲名稱 (每行一個，輸入空行結束):")

    while True:
        song = input()
        if not song:
            break
        song_names.append(song)

    # 選擇是否優先下載完整版
    prefer_full = input("是否優先選擇完整版歌曲? (y/n, 預設 y): ").lower() != 'n'

    # 選擇是否手動選擇每首歌
    manual_selection = input("是否手動從搜尋結果中選擇每首歌? (y/n, 預設 n): ").lower() == 'y'

    # 新增：限流選項，避免429錯誤
    apply_rate_limit = input("是否啟用下載間隔以避免429錯誤? (y/n, 預設 y): ").lower() != 'n'
    rate_limit_args = "--limit-rate 500K --sleep-interval 10" if apply_rate_limit else ""
    if rate_limit_args and extra_params:
        extra_params = f"{extra_params} {rate_limit_args}"
    elif rate_limit_args:
        extra_params = rate_limit_args

    print(f"\n開始搜尋和下載 {len(song_names)} 首歌曲...")
    success_count = 0

    for i, song in enumerate(song_names, 1):
        print(f"\n處理第 {i}/{len(song_names)} 首歌曲:")

        url = None
        if manual_selection:
            url = select_from_search_results(song, extra_params)
        else:
            url = search_song(song, prefer_full=prefer_full, extra_params=extra_params)

        if url:
            # 使用搜尋關鍵字作為檔名，或詢問是否修改檔名
            custom_name = song
            if download_as_mp3(url, custom_name, extra_params):
                success_count += 1
        else:
            print(f"無法找到歌曲: {song}")

    print(f"\n下載完成! 成功: {success_count}/{len(song_names)}")

# 原有的URL下載功能
def download_by_url(extra_params=""):
    while True:
        youtube_url = input("請輸入 YouTube 影片網址 (輸入 '0' 退出): ")
        if youtube_url.lower() == '0':
            break

        if "youtube.com" in youtube_url or "youtu.be" in youtube_url:
            # 詢問是否使用自定義檔名
            use_custom = input("是否使用自定義檔名? (y/n): ").lower() == 'y'

            custom_name = None
            if use_custom:
                custom_name = input("請輸入檔名 (不需要副檔名): ")

            download_as_mp3(youtube_url, custom_name, extra_params)
        else:
            print("請輸入有效的 YouTube 網址!")

    print("程式已結束")

# 批次下載多個URL
def batch_download_urls(extra_params=""):
    urls = []
    print("請輸入多個 YouTube 網址 (每行一個，輸入空行結束):")

    while True:
        url = input()
        if not url:
            break
        urls.append(url)

    # 新增：限流選項，避免429錯誤
    apply_rate_limit = input("是否啟用下載間隔以避免429錯誤? (y/n, 預設 y): ").lower() != 'n'
    rate_limit_args = "--limit-rate 500K --sleep-interval 10" if apply_rate_limit else ""
    if rate_limit_args and extra_params:
        extra_params = f"{extra_params} {rate_limit_args}"
    elif rate_limit_args:
        extra_params = rate_limit_args

    print(f"\n開始下載 {len(urls)} 個影片...")
    success_count = 0

    for i, url in enumerate(urls, 1):
        print(f"\n處理第 {i}/{len(urls)} 個影片:")
        if download_as_mp3(url, None, extra_params):
            success_count += 1

    print(f"\n下載完成! 成功: {success_count}/{len(urls)}")

# 選擇下載模式
print("進階 YouTube 音樂下載器 (優化版) - 解決429錯誤")
print("檔案將儲存至:", output_dir)

# 先設置處理429錯誤的機制
print("\n== 防止YouTube 429錯誤設置 ==")
extra_params = setup_cookies()

# 測試連接
if extra_params:
    test_youtube_connection(extra_params)

print("\n== 請選擇下載模式 ==")
print("1. 輸入歌曲名稱下載 (可選擇完整版)")
print("2. 批次下載多首歌曲 (輸入名稱)")
print("3. 輸入 YouTube 網址下載")
print("4. 批次下載多個 YouTube 網址")

choice = input("請選擇模式 (1/2/3/4): ")
if choice == "1":
    download_song_by_name(extra_params)
elif choice == "2":
    batch_download_songs(extra_params)
elif choice == "3":
    download_by_url(extra_params)
elif choice == "4":
    batch_download_urls(extra_params)
else:
    print("無效的選擇，默認使用歌曲名稱下載模式")
    download_song_by_name(extra_params)
